% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map-interval.r
\name{map_interval_dfc}
\alias{map_interval_dfc}
\alias{map_interval_dfr}
\alias{map_interval}
\title{Apply a function to each group and iterated interval in a data.frame}
\usage{
map_interval_dfc(.x, .gen, .f, time, end = NULL, ...)
}
\arguments{
\item{.x}{a data.frame to apply a function to.}

\item{.gen}{a time interval iterator generator.}

\item{.f}{the function to apply to the group and hourly interval.}

\item{time}{the column denoting the checkin times.}

\item{end}{the end time. By default this is the the end of the hour
corresponding to the largest time.}

\item{...}{other arguments to pass to the function \code{.f}.}
}
\description{
For checking data represented as a data frame, a column
contatining timestamps, and other information associated with the checkin,
this functions applies a specified function to the subsets of the
data falling within the time interval. This can be used to get check in
counts for each 15 minutes, for example. In addition, grouped data is
supported (using dplyr::group_by) to further specify subsets of specific
groups and time intervals on which the function should be applied. The
\code{map_interval_dfr()} function appends the results by row and
\code{map_interval_dfc()} function appends results by column.
}
\examples{

library(lubridate)
library(dplyr)
library(purrr)

data(checkins)

# Create a data set for the first hour of the checkins data.
x <- checkins \%>\%
  filter(timestamp < min(timestamp) + hours(1))

# Create a generator for that hour with 15 minute durations.

gen_15 <- partial(time_interval_gen,
                  start = min(x$timestamp),
                  end = max(x$timestamp),
                  duration = minutes(15))

checkin_count <- function(it) {
  tibble(unique_ids = length(unique(it$id)), count = nrow(it))
}

# Count the number of checkins for each interval.
map_interval_dfr(x, gen_15, checkin_count, "timestamp")

}
