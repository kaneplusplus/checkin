% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/map-interval.r
\name{map_hourly_interval_dfr}
\alias{map_hourly_interval_dfr}
\alias{map_hourly_interval_dfc}
\alias{map_hourly_interval}
\title{Apply a function to each group and hourly interval in a data.frame}
\usage{
map_hourly_interval_dfr(.x, .f, time, end = NULL, ...)
}
\arguments{
\item{.x}{a data.frame to apply a function to.}

\item{.f}{the function to apply to the group and hourly interval.}

\item{time}{the column denoting the checkin times.}

\item{end}{the end time. By default this is the the end of the hour
corresponding to the largest time.}

\item{...}{other arguments to pass to the function \code{.f}.}
}
\description{
For checking data represented as a data frame, a column
contatining timestamps, and other information associated with the checkin,
this functions applies a specified function to the subsets of the
data falling within the time interval. This can be used to get check in
counts for each hour, for example. In addition, grouped data is supported
(using dplyr::group_by) to further specify subsets of specific groups and
time intervals on which the function should be applied. The
\code{map_hourly_interval_dfr()} function appends the results by row and
\code{map_hourly_interval_dfc()} function appends results by column.
}
\examples{
# Count the number of transitions between locations in the checkin data.

library(dplyr)

data(checkins)

 from_to <- function(it) {
   it$duration <- c(diff(it$timestamp), 0)
   units(it$duration) <- "secs"
   it$duration <- as.numeric(it$duration)
   from_duration <- sum(it$duration[it$location == it$location[1]])
   tibble(from=it$location[1],
          to = it$location[nrow(it)],
          timestamp = it$timestamp[1],
          from_duration = from_duration)
 }

 y <- checkins \%>\%
   head(100) \%>\%
   group_by(id) \%>\%
   map_hourly_interval_dfr(from_to, time = "timestamp") 

}
