% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interval-iterator.r
\name{time_interval_gen}
\alias{time_interval_gen}
\title{Create a time interval iterator generator}
\usage{
time_interval_gen(
  x,
  time,
  start,
  end,
  duration,
  start_loc = TRUE,
  end_loc = TRUE
)
}
\arguments{
\item{x}{the data frame of checkins.}

\item{time}{the column denoting the timestamp.}

\item{start}{the beginning of the interval.}

\item{end}{the end of the interval.}

\item{duration}{the period for each iteration.}

\item{start_loc}{should the starting location be included? Default TRUE.}

\item{end_loc}{should the starting location be included? Default TRUE.}
}
\description{
The time interval generator creates an iterator, which
iterates over consecutive periods of length duration. This function is
a more general version of the \code{hour_check_gen()} function, which iterates
over consecutive hours based on start and stop defined by the maximum and
minimum times defined in a check data set.
}
\examples{

library(lubridate)
library(dplyr)
library(purrr)

data(checkins)

# Create a data set for the first hour of the checkins data.
x <- checkins \%>\%
  filter(timestamp < min(timestamp) + hours(1))
 
# Create a generator for that hour with 15 minute durations.  

gen_15 <- partial(time_interval_gen,
                  start = min(x$timestamp), 
                  end = max(x$timestamp),
                  duration = minutes(15))

checkin_count <- function(it) {
  tibble(unique_ids = length(unique(it$id)), count = nrow(it))
}

# Count the number of checkins for each interval.
map_interval_dfr(x, gen_15, checkin_count, "timestamp")

}
\seealso{
hour_checkin_gen
}
